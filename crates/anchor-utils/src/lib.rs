//! # Anchor Utils
//!
//! Utility functions for simplifying Anchor framework development on Solana.
//!
//! This crate provides helper functions that make it easier to work with Anchor programs,
//! particularly when creating instructions from Anchor's generated client code.
//!
//! ## Features
//!
//! - **Simplified instruction creation**: Convert Anchor's generated structs directly to Solana instructions
//! - **Type-safe interface**: Leverages Anchor's type system for compile-time safety
//! - **Zero overhead**: Minimal abstraction layer with no runtime cost

use anchor_lang::prelude::*;
use anchor_lang::{InstructionData, ToAccountMetas};
use solana_program::instruction::Instruction;

/// Creates a new Anchor instruction from the generated `declare_program!` client structs
///
/// This function simplifies the process of creating Solana instructions from Anchor's
/// generated types, providing a clean interface that handles the conversion automatically.
///
/// # Arguments
///
/// * `program_id` - The on-chain program's public key
/// * `accounts` - Account struct that implements `ToAccountMetas` (generated by Anchor)
/// * `data` - Instruction data struct that implements `InstructionData` (generated by Anchor)
///
/// # Returns
///
/// A [solana_program::instruction::Instruction] ready to be added to a transaction.
///
/// # Example
///
/// ```rust
/// use anchor_utils::anchor_instruction;
/// use anchor_lang::prelude::*;
/// use solana_program::instruction::Instruction;
///
/// // Using Anchor's generated types from declare_program!
/// declare_program!(quarry_mine);
///
/// # let user_authority = Pubkey::new_unique();
/// # let miner_account = Pubkey::new_unique();
/// # let quarry_account = Pubkey::new_unique();
/// # let rewarder_account = Pubkey::new_unique();
/// # let token_account = Pubkey::new_unique();
/// # let miner_vault_account = Pubkey::new_unique();
/// # let token_program_id = Pubkey::new_unique();
///
/// let instruction: Instruction = anchor_instruction(
///     quarry_mine::ID,
///     quarry_mine::client::accounts::StakeTokens {
///         authority: user_authority,
///         miner: miner_account,
///         quarry: quarry_account,
///         rewarder: rewarder_account,
///         token_account: token_account,
///         miner_vault: miner_vault_account,
///         token_program: token_program_id,
///     },
///     quarry_mine::client::args::StakeTokens {
///         amount: 1_000_000,
///     },
/// );
/// ```
///
/// # Working with Real Programs
///
/// Here's an example using the Quarry mining program:
///
/// ```rust,ignore
/// use anchor_lang::prelude::*;
/// use anchor_utils::anchor_instruction;
///
/// // Load the Quarry program IDL
/// declare_program!(quarry_mine);
///
/// // Create a stake instruction
/// let stake_ix = anchor_instruction(
///     quarry_mine::ID,
///     quarry_mine::accounts::UserStake {
///         authority: user_authority,
///         miner: miner_account,
///         quarry: quarry_account,
///         token_program: token::ID,
///     },
///     quarry_mine::instruction::UserStake {
///         amount: 1_000_000,
///     },
/// );
/// ```
pub fn anchor_instruction(
    program_id: Pubkey,
    accounts: impl ToAccountMetas,
    data: impl InstructionData,
) -> Instruction {
    Instruction {
        program_id,
        accounts: accounts.to_account_metas(None),
        data: data.data(),
    }
}
